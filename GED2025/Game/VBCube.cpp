#include "pch.h"
#include "VBCube.h"
#include "stringHelp.h"

void VBCube::Init(ID3D11Device* _GD, IEffectFactory* _EF, Game* _gam)
{
	// this is most certainly not the most efficient way of doing most of this
	//but it does give you a very clear idea of what is actually going on

	//calculate number of vertices and primitives
	int numVerts = 6 * 6 * (m_size - 1) * (m_size - 1);
	m_numPrims = numVerts / 3;
	m_vertices = new myVertex[numVerts];
	WORD* indices = new WORD[numVerts];

	//as using the standard VB shader set the tex-coords somewhere safe
	for (int i = 0; i < numVerts; i++)
	{
		indices[i] = (WORD)i;
		m_vertices[i].texCoord = Vector2::One;
	}

	//in each loop create the two triangles for the matching sub-square on each of the six faces
	int vert = 0;
	for (int i = -(m_size - 1) / 2; i < (m_size - 1) / 2; i++)
	{
		for (int j = -(m_size - 1) / 2; j < (m_size - 1) / 2; j++)
		{
			if (m_sides[SIDE_TOP])
			{
				//top
				m_vertices[vert].Color = Color(1.0f, 0.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)i, 0.5f * (float)(m_size - 1), (float)j);
				m_vertices[vert].Color = Color(1.0f, 0.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)i, 0.5f * (float)(m_size - 1), (float)(j + 1));
				m_vertices[vert].Color = Color(1.0f, 0.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(i + 1), 0.5f * (float)(m_size - 1), (float)j);

				m_vertices[vert].Color = Color(1.0f, 0.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(i + 1), 0.5f * (float)(m_size - 1), (float)j);
				m_vertices[vert].Color = Color(1.0f, 0.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)i, 0.5f * (float)(m_size - 1), (float)(j + 1));
				m_vertices[vert].Color = Color(1.0f, 0.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(i + 1), 0.5f * (float)(m_size - 1), (float)(j + 1));
			}
			if (m_sides[SIDE_BACK])
			{
				//back
				m_vertices[vert].Color = Color(0.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)i, (float)j, 0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(i + 1), (float)j, 0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)i, (float)(j + 1), 0.5f * (float)(m_size - 1));

				m_vertices[vert].Color = Color(0.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(i + 1), (float)j, 0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(i + 1), (float)(j + 1), 0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)i, (float)(j + 1), 0.5f * (float)(m_size - 1));
			}
			if (m_sides[SIDE_RIGHT])
			{
				//right
				m_vertices[vert].Color = Color(0.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(0.5f * (float)(m_size - 1), (float)i, (float)j);
				m_vertices[vert].Color = Color(0.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(0.5f * (float)(m_size - 1), (float)(i + 1), (float)j);
				m_vertices[vert].Color = Color(0.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(0.5f * (float)(m_size - 1), (float)i, (float)(j + 1));

				m_vertices[vert].Color = Color(0.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(0.5f * (float)(m_size - 1), (float)(i + 1), (float)j);
				m_vertices[vert].Color = Color(0.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(0.5f * (float)(m_size - 1), (float)(i + 1), (float)(j + 1));
				m_vertices[vert].Color = Color(0.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(0.5f * (float)(m_size - 1), (float)i, (float)(j + 1));
			}
			
			
			if (m_sides[SIDE_BOTTOM])
			{
				//Bottom
				m_vertices[vert].Color = Color(1.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)j, -0.5f * (float)(m_size - 1), (float)i);
				m_vertices[vert].Color = Color(1.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(j + 1), -0.5f * (float)(m_size - 1), (float)i);
				m_vertices[vert].Color = Color(1.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)j, -0.5f * (float)(m_size - 1), (float)(i + 1));

				m_vertices[vert].Color = Color(1.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)j, -0.5f * (float)(m_size - 1), (float)(i + 1));
				m_vertices[vert].Color = Color(1.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(j + 1), -0.5f * (float)(m_size - 1), (float)i);
				m_vertices[vert].Color = Color(1.0f, 1.0f, 0.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(j + 1), -0.5f * (float)(m_size - 1), (float)(i + 1));
			}

			if (m_sides[SIDE_FRONT])
			{
				//front
				m_vertices[vert].Color = Color(0.0f, 1.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)j, (float)i, -0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)j, (float)(i + 1), -0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(j + 1), (float)i, -0.5f * (float)(m_size - 1));

				m_vertices[vert].Color = Color(0.0f, 1.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)j, (float)(i + 1), -0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(j + 1), (float)(i + 1), -0.5f * (float)(m_size - 1));
				m_vertices[vert].Color = Color(0.0f, 1.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3((float)(j + 1), (float)i, -0.5f * (float)(m_size - 1));
			}
			if (m_sides[SIDE_LEFT])
			{
				//left
				m_vertices[vert].Color = Color(1.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(-0.5f * (float)(m_size - 1), (float)j, (float)i);
				m_vertices[vert].Color = Color(1.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(-0.5f * (float)(m_size - 1), (float)j, (float)(i + 1));
				m_vertices[vert].Color = Color(1.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(-0.5f * (float)(m_size - 1), (float)(j + 1), (float)i);

				m_vertices[vert].Color = Color(1.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(-0.5f * (float)(m_size - 1), (float)j, (float)(i + 1));
				m_vertices[vert].Color = Color(1.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(-0.5f * (float)(m_size - 1), (float)(j + 1), (float)(i + 1));
				m_vertices[vert].Color = Color(1.0f, 0.0f, 1.0f, 1.0f);
				m_vertices[vert++].Pos = Vector3(-0.5f * (float)(m_size - 1), (float)(j + 1), (float)i);
			}
		}
	}

	//carry out some kind of transform on these vertices to make this object more interesting
	Transform(indices);

	//calculate the normals for the basic lighting in the base shader
	for (UINT i = 0; i < m_numPrims; i++)
	{
		WORD V1 = (WORD)(3 * i);
		WORD V2 = V1 + 1;
		WORD V3 = V1 + 2;

		//build normals
		Vector3 norm;
		Vector3 vec1 = m_vertices[V1].Pos - m_vertices[V2].Pos;
		Vector3 vec2 = m_vertices[V3].Pos - m_vertices[V2].Pos;
		norm = vec1.Cross(vec2);
		norm.Normalize();

		m_vertices[V1].Norm = norm;
		m_vertices[V2].Norm = norm;
		m_vertices[V3].Norm = norm;
	}


	BuildIB(_GD, indices);
	BuildVB(_GD, numVerts, m_vertices);

	delete[] indices;    //this is no longer needed as this is now in the index Buffer
	delete[] m_vertices; //this is no longer needed as this is now in the Vertex Buffer
	m_vertices = nullptr;
}

void VBCube::ConfigureSides(int _sidesToLoad)
{
	//convert integer to binary and set sides accordingly
	for (int i = 0; i < 6; ++i)
	{
		if (_sidesToLoad & (1 << i))
		{
			m_sides[i] = true;
			
		}
		else
		{
			m_sides[i] = false;
		}

	}
	
	
}

void VBCube::Load(ifstream& _file)
{
	GameObject::Load(_file);
	StringHelp::Int(_file, "SIZE", m_size);
	
	//sides to draw: order is TOP, BACK, RIGHT, BOTTOM, FRONT, LEFT
	//for (int i = 0; i < 6; ++i) m_sides[i] = true;

	if (m_name == "PROCGEN")
	{
		int sidesToLoad = 0;
		StringHelp::Int(_file, "SIDES", sidesToLoad);
		ConfigureSides(sidesToLoad);
	}
	else
	{
		//default is all sides
		ConfigureSides(63);
	}
	

}
